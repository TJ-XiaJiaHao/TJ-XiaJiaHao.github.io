<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(八)：mpvue和wepy问题总结]]></title>
    <url>%2F2019%2F04%2F09%2Fmpvue%E5%92%8Cwepy%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[mpvue 问题总结 - 2018.03.28#issue地址 { { } } 中不支持复杂的 js 语法，因为 mpvue 会把 { { } } 中的内容直接编译到 wxml 中，受限于微信小程序的能力。 不支持复杂 slot，具名 slot 和单个 slot 插槽可以支持，但是 slot 的 scoped 不支持，即下面的情况无法获取 item 和 index 123&lt;component v-for=&quot;item in todos&quot; :key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; /* 获取不到 */&lt;/component&gt; 组件渲染是串行的，而原生的是并行的。假设一个页面中用到了5个A组件，一个组件渲染时间大约为100毫秒，那么在原生中所有组件渲染完成约为100毫秒（并行渲染），而在mpvue中则需要约为500毫秒（串行渲染）。 当动态绑定一个数据时，某些情况下即使该数据没有发生变化，也会被刷新。如下面是一个简单的 slider，想要在拖动的时候实时修改标题，但是会不断地重新赋值为 chapterIndex 的值，就会出现回弹的 bug ，而且松手后的 value 不是最新的 value，而是 chapterIndex（下面注释部分为解决方案）。scroll-view 如果动态绑定 scrolltop 也有同样的问题。 1234567891011121314151617// 假设现在chapterIndex为0，slider最大为10&lt;slider :value=&quot;chapterIndex&quot; @changing=&quot;sliderChooseChaptering&quot; @change=&quot;sliderChooseChaptered&quot;&gt;// 拖动slider到5处sliderChooseChaptering(e) &#123; // this.chapterIndex = undefined; // 通过设置为undefined可以避免滚动条回退 this.toolbarTitle = &apos;new title&apos;; // 改动了标题变量，但是slider会被重新赋值，小圆点回退到0处&#125;,sliderChooseChaptered(e) &#123; let chapterIndex = e.mp.detail.value; console.log(chapterIndex); // 值为0，而不是5 // this.chapterIndex = chapterIndex; // 重新赋值&#125; 上传体验版的时候，访问路径为 pages/***/main，如 pages/index/main 图片 url 不能使用相对路径， 否则在手机上将显示不出来 123456&lt;image :src = &apos;imgUrl&apos;&gt;&lt;/image&gt;imgUrl() &#123; return &apos;../../static/images/test.png&apos;; // 错误方法 return &apos;/static/images/test.png&apos;; // 正确方法&#125; scroll-view 中无法监听到垂直的 touchmove (原生的也有同样的问题) 123456789101112 &lt;scroll-view style=&quot;height:100rpx&quot; scroll-y @touchstart=&quot;tstart&quot; @touchend=&quot;tend&quot; @touchmove=&quot;tmove&quot;&gt;&lt;div style=&quot;height: 200rpx&quot;&gt;hahahah&lt;/div&gt;&lt;/scroll-view&gt;tstart() &#123; console.log(&apos;tstart&apos;);&#125;,tend() &#123; console.log(&apos;tend&apos;);&#125;,tmove() &#123; console.log(&apos;tmove&apos;);&#125;, wepy 问题总结 - 2018-03-12 组件动态绑定只能绑定一层，如 :nickName.sync=&quot;nickName&quot;，当父组件的 nickName 改变时，子组件中的数据没有刷新 1.7.2中可以使用原生组件解决了组件共享数据的问题，但是父组件无法再通过 $broadcast 下传事件了 当使用 image 时可能会导致体验 bug ，出现场景：侧滑组件分上下两层，上层含有 image 标签，当快速加载多个侧滑组件时，会出现下层按钮闪现的情况（百来毫秒），降低体验感 没有数据共享？？ 组件循环渲染一定要用repeat，而repeat本身充满了bug，真的让人头疼 #issue mpvue相对于wepy的优势 mpvue 组件化开发能力更强，wepy 组件化支持仍有很多不足，其中组件数据共享的问题简直鸡肋。虽然在1.7.2之后可以使用原生的组件从而达到数据隔离的目的，但是原生语法和 wepy 语法很容易发生混淆。如果要循环渲染组件，则一定要用到 repeat 标签，而 repeat 标签本身充满着 bug。 mpvue支持 vuex，wepy 开发过程中多页面间共享的数据很难维护，只能用 globaldata 或者 storage 来达到数据共享效果。 语法和特性与 vue 更加类似，wepy 只是借鉴了 vue，本身和 vue 还是有较大差别的。 mpvue相对于wepy的劣势 和wepy一样，{ { } } 中不支持复杂的js语法，因为 mpvue 会把 { { } }中的内容直接编译到 wxml 中，受限于微信小程序的能力。 不支持复杂 slot，具名 slot 和单个 slot 插槽可以支持，但是 slot 的 scoped 不支持，即下面的情况无法获取 item 和 index 123&lt;component v-for=&quot;item in todos&quot; :key=&quot;item&quot;&gt; &#123;&#123; item &#125;&#125; /* 获取不到 */&lt;/component&gt; 组件中不支持transition，动画可能要跪]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(七)：组件支持多个内容槽(slot)]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%B9%E6%A7%BD%2F</url>
    <content type="text"><![CDATA[组件A支持单个内容槽 a.json 123&#123; "component": true&#125; a.wxml 123&lt;view class="inner"&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/view&gt; a.js 1Component(&#123;&#125;) 在B中使用组件A b.json 12345&#123; "usingComponents": &#123; "component-a": "../components/a" &#125;&#125; b.wxml 12345&lt;view&gt; &lt;component-a&gt; 单个内容槽内容 &lt;/component-a&gt;&lt;/view&gt; b.js 1Page(&#123;&#125;) 组件C支持多个内容槽需要在 options 中设置 mutipleSlots 为 true c.json 123&#123; "component": true&#125; c.wxml 12345&lt;view class="inner"&gt; &lt;slot name="before"&gt;&lt;/slot&gt; &lt;view&gt;这里是组件的内部细节&lt;/view&gt; &lt;slot name="after"&gt;&lt;/slot&gt;&lt;/view&gt; c.js 12345Component(&#123; options: &#123; mutipleSlots: true &#125;&#125;) 在D中使用组件C d.json 12345&#123; "usingComponents": &#123; "component-c": "../components/c" &#125;&#125; d.wxml 123456&lt;view&gt; &lt;component-c&gt; &lt;view slot="before"&gt;这里是插入到组件slot name="before"中的内容&lt;/view&gt; &lt;view slot="after"&gt;这里是插入到组件slot name="after"中的内容&lt;/view&gt; &lt;/component-c&gt;&lt;/view&gt; d.js 1Page(&#123;&#125;)]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(六)：支付流程]]></title>
    <url>%2F2019%2F03%2F28%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[支付流程示意图 预支付（请求后台，后台请求微信服务获取支付信息） 调用 API 发起支付：wx.requestPayment({}) jsAPI、jsSDK、小程序支付的对比(开发步骤) 对比栏目 JSAPI JSSDK 小程序 统一下单 都需要先获取到Openid，调用相同的API 同 同 调起数据签名 五个字段参与签名(区分大小写)：appId,nonceStr,package,signType,timeStamp 同 同 调起支付页面协议 HTTP或HTTPS HTTP或HTTPS HTTPS 支付目录 有 有 无 授权域名 有 有 无 回调函数 有 success回调 complete、fail、success回调函数 小程序调起支付 API 说明1234567891011wx.requestPayment(&#123; 'timeStamp': '', 'nonceStr': '', 'package': '', 'signType': 'MD5', 'paySign': '', 'success':function(res)&#123;&#125;, 'fail':function(res)&#123;&#125;, 'complete':function(res)&#123;&#125;&#125;) paySign 字段包含信息说明： 1paySign = MD5(appId=wxd678efh567hg6787&amp;nonceStr=5K8264ILTKCH16CQ2502SI8ZNMTM67VS&amp;package=prepay_id=wx2017033010242291fcfe0db70013231072&amp;signType=MD5&amp;timeStamp=1490840662&amp;key=qazwsxedcrfvtgbyhnujmikolp111111) = 22D9B4E54AB1950F51E0649E8810ACD6 字段名 变量名 必填 类型 示例值 描述 小程序ID appId 是 String wx***6787 微信分配的小程序ID 时间戳 timeStamp 是 String 14***662 时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间 随机串 nonceStr 是 String 5K***67VS 随机字符串，不长于32位。推荐随机数生成算法 数据包 package 是 String prepay_id=wx***1072 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=wx**1072 签名方式 signType 是 String MD5 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 参数说明： 参数 类型 必填 说明 timeStamp String 是 时间戳从1970年1月1日00:00:00至今的秒数,即当前的时间 nonceStr String 是 随机字符串，长度为32个字符以下。 package String 是 统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=* signType String 是 签名类型，默认为MD5，支持HMAC-SHA256和MD5。注意此处需与统一下单的签名类型一致 paySign String 是 签名,具体签名方案参见微信公众号支付帮助文档; success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 回调说明： 回调类型 errMsg 说明 success requestPayment:ok 调用支付成功 fail requestPayment:fail cancel 用户取消支付 fail requestPayment:fail (detail message) 调用支付失败，其中 detail message 为后台返回的详细失败原因 预支付流程前端提交需支付的信息到开发者服务器，开发者服务器再提交到微信，而后返回需要的信息12345678910111213141516&#123; "sign":"A2****************A6", "timestamp":"14****************68", "package":"Sign=WXPay", "partnerId":"14****************02", "appid":"wx****************ab", "nonceStr":"9f****************37", "prepayId":"wx****************54"&#125; 发起支付md5下载链接：https://code.csdn.net/snippets/2019875/master/download1234567891011121314151617181920var MD5Util = require('../../../utils/md5.js');var sign = '';var signA = "appId="+app.appId+"&amp;nonceStr="+res.data.nonceStr+"&amp;package=prepay_id="+res.data.prepayId+"&amp;signType=MD5&amp;timeStamp="+res.data.timestamp;var signB = signA+"&amp;key="+app.key;sign = MD5Util.MD5(signB).toUpperCase();wx.requestPayment(&#123; nonceStr: res.data.nonceStr, package: "prepay_id="+res.data.prepayId, signType: 'MD5', timeStamp: res.data.timestamp, paySign: sign, success: function(res)&#123; console.log("支付成功"); &#125;, fail: function() &#123; &#125;, complete: function() &#123; &#125;&#125;) 代码Demo123456789101112131415161718192021222324252627282930313233wx.request(&#123; url: 'https://调用服务器获取微信统一下单数据', method: 'GET', data: &#123; uid: uid, id: id &#125;, success: function (res) &#123; var nowTime = new Date() var appId = res.data.appid var timeStamp1 = Math.round((nowTime.getTime()) / 1000) var timeStamp = timeStamp1.toString() var nonceStr = res.data.nonce_str var package = "prepay_id=" + res.data.prepay_id var signType = "MD5" var key = "Niskh5234234WYk4323HyE78m2sE"//商户平台的key var sign = res.data.sign var paySign = md5.hexMD5("appId=" + appId + "&amp;nonceStr=" + nonceStr + "&amp;package=" + package + "&amp;signType=MD5&amp;timeStamp=" + timeStamp + "&amp;key=" + key) wx.requestPayment(&#123; timeStamp: timeStamp, //随机字符串，长度为32个字符以下。 nonceStr: nonceStr, //统一下单接口返回的 prepay_id 参数值，提交格式如：prepay_id=* package: package, //签名算法，暂支持 MD5 signType: 'MD5', paySign: paySign, success: function (res) &#123; &#125;, fail: function (res) &#123; &#125;, complete: function (res) &#123; &#125; &#125;) &#125;&#125;)]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(五)：分享 & 分享到朋友圈]]></title>
    <url>%2F2019%2F03%2F21%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[页面基础分享能力基本的页面分享，只需要在页面中设置 onShareAppMessage 即可，如果分享的内容各个页面保持一致，建议进行一定的封装，如封装到 Page 的能力中。 1234567891011121314151617181920App(&#123; // 获取分享卡片内容 getShareMessage(path) &#123; return &#123; title: '分享标题', imageUrl: '分享图片', path: path || '分享默认路径' &#125;; &#125;, enhancePage() &#123; const oPage = Page; Page = config =&gt; oPage(Object.assign(config, &#123; getShareMessage: this.getShareMessage, &#125;)); &#125;, onLaunch() &#123; this.enhancePage(); &#125;,&#125;) 12345Page(&#123; onShareAppMessage() &#123; return this.getShareMessage(1); &#125;&#125;) 用户点击按钮主动触发分享只需要设置按钮的 open-type 为 share 就可以自动触发页面的 onShareAppMessage 了。1&lt;button open-type="share"&gt;分享按钮&lt;/button&gt; 获取群聊中的分享信息限于隐私保护，个人分享的信息已经不再能拿到了，但是我们可以获取分享所在群的信息。 1.需要在分享页设置 ticket 信息 1234onLoad() &#123; // 配置分享，用以区分分享到个人还是群 wx.showShareMenu(&#123;withShareTicket: true&#125;);&#125; 2.在 onShareAppMessage 里获取群信息 12345678910111213141516171819onShareAppMessage() &#123; return &#123; title: '分享', path: '/pages/index', success: (res) =&gt; &#123; const tickets = res.shareTickets; if (res.shareTickets) &#123; wx.getShareInfo(&#123; shareTicket: tickets[0], success: (data) =&gt; &#123; console.log('分享到群: ', data); &#125;, &#125;); &#125; else &#123; console.log('分享到个人'); &#125; &#125;, &#125;;&#125; 3.在 APP.onLaunch 或者 App.onShow 里获取群信息 12345678910App(&#123; onShow: (options) =&gt; &#123; wx.getShareInfo(&#123; shareTicket: options.shareTicket, success: (res) =&gt; &#123; // 请求微信服务器获取群信息 &#125; &#125;) &#125;&#125;) 分享到朋友圈小程序是不支持直接分享到朋友圈的，只能通过保存图片并引导用户主动发送朋友圈。下面的例子是一个分享动态生成的图片。 第一步：素材预下载，素材不支持远程URL，需要下载到本地（如小程序二维码和书封） 12345678910111213141516171819202122232425262728293031323334353637383940// 获取小程序二维码downloadAppCode() &#123; return new Promise((resolve, rej) =&gt; &#123; wx.downloadFile(&#123; url: '后台获取二维码接口', success: (res) =&gt; &#123; resolve(res.tempFilePath); &#125;, fail: (res) =&gt; &#123; resolve(''); &#125; &#125;); &#125;);&#125;,// 下载文件downloadFile(url) &#123; return new Promise((resolve, rej) =&gt; &#123; if (url)&#123; wx.downloadFile(&#123; url: url, success: (res) =&gt; &#123; resolve(res.tempFilePath); &#125;, &#125;); &#125; else resolve(); &#125;);&#125;,// 下载所有书封到本地downloadCovers(books) &#123; const urls = books.map((book) =&gt; this.getBookCover(book.bookId)); Promise.all([ this.downloadFile(urls[0]), this.downloadFile(urls[1]), this.downloadFile(urls[2]), this.downloadFile(urls[3]), this.downloadFile(urls[4]), this.downloadAppCode(), ]).then((res) =&gt; &#123; const appCode = res[res.length - 1]; // 获取小程序二维码地址 res = res.splice(0, res.length - 1); // 所有书封地址 res = res.filter(item =&gt; item); // 过滤空书封 this.setData(&#123; localCovers: res, appCode &#125;); this.drawShareImg(); &#125;);&#125; 第二步：通过canvas绘制需要被保存分享的图片 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// 绘制分享图片drawShareImg() &#123; const ctx = wx.createCanvasContext('shareImg'); const covers = this.data.localCovers; // 背景 ctx.save() ctx.setFillStyle('white') ctx.fillRect(0, 0, 260, 370); ctx.restore() // nickname ctx.setFillStyle('#111111'); ctx.setFontSize(14); ctx.setTextAlign('center'); ctx.fillText(this.data.userInfo.nickName, 130, 42, 260); // 文案 心愿书屋 // ctx.drawImage('../assets/images/share/share_icon_xysw.svg', 70, 52, 120, 30); ctx.setFillStyle('#111111'); ctx.setTextAlign('center'); ctx.font = "30px SourceHanSerifCNMedium"; ctx.fillText('心愿书屋', 130, 82, 260); // 书封边框 ctx.setStrokeStyle('rgba(0,0,0,0.1)'); if(covers[3]) ctx.strokeRect(21, 150, 42, 56); if(covers[4]) ctx.strokeRect(197, 150, 42, 56); if(covers[1]) ctx.strokeRect(51, 126, 60, 80); if(covers[2]) ctx.strokeRect(149, 126, 60, 80); if(covers[0]) ctx.strokeRect(91, 102, 78, 104); // 书封 if(covers[3]) ctx.drawImage(covers[3], 21, 150, 42, 56); if(covers[4]) ctx.drawImage(covers[4], 197, 150, 42, 56); if(covers[1]) ctx.drawImage(covers[1], 51, 126, 60, 80); if(covers[2]) ctx.drawImage(covers[2], 149, 126, 60, 80); if(covers[0]) ctx.drawImage(covers[0], 91, 102, 78, 104); // 矩形背景 ctx.rect(0, 226, 260, 66); ctx.setFillStyle('#FFDCE7'); ctx.fill(); // 引号 ctx.drawImage('/assets/images/share/share_icon_left.png', 20, 242, 20, 12); ctx.drawImage('/assets/images/share/share_icon_right.png', 220, 264, 20, 12); // 二维码 ctx.drawImage(this.data.appCode, 108, 309, 44, 44); // 文案 我已经领了129书币 ctx.setFillStyle('#773A4D'); ctx.font = "14px SourceHanSerifCNMedium"; ctx.setTextAlign('center'); ctx.fillText('我已经领了129书币', 130, 254, 260); // 文案 天天领币，免费看书 ctx.setFillStyle('#773A4D'); ctx.font = "14px SourceHanSerifCNMedium"; ctx.setTextAlign('center'); ctx.fillText('天天领币，免费看书', 130, 274, 260); // 文案 识别小程序码 ctx.setFillStyle('#9B9B9B'); ctx.setFontSize(12); ctx.setTextAlign('left'); ctx.fillText('识别小程序码', 30, 337, 260); // 文案 进入心愿书屋 ctx.setFillStyle('#9B9B9B'); ctx.font = "12px SourceHanSerifCNMedium"; ctx.setTextAlign('left'); ctx.fillText('进入心愿书屋', 158, 337, 260); ctx.draw();&#125;, 第三步：通过微信api下载图片到手机相册 1234567891011121314151617181920212223242526272829canvasToFile() &#123; wx.canvasToTempFilePath(&#123; x: 0, y: 0, width: 260, // 画布区域宽度 height: 370, // 画布区域高度 destWidth: 260 * 4, // 保存图片宽度 destHeight: 370 * 4, // 保存图片高度 canvasId: 'shareImg', success: (res) =&gt; &#123; this.saveImage(res.tempFilePath); &#125;, fail: function (err) &#123; console.log('生成图片失败'); &#125;, &#125;);&#125;, // 保存图片saveImage(filePath) &#123; wx.saveImageToPhotosAlbum(&#123; filePath:filePath, success: (res) =&gt; &#123; this.showSuccess('图片保存成功'); &#125;, fail: () =&gt; &#123; this.showError('图片保存到相册失败', '图片无法保存到相册，请稍后重试'); &#125;, &#125;);&#125;, 本地图片处理注意事项 模拟器上都是骗人的 12341. 不要使用相对路径，只能使用绝对路径2. 图片不支持svg不支持svg不支持svg3. 图片不支持base64，只支持本地图片和网络图片两种* 如果使用了相对路径、svg、base64，模拟器上运行顺畅的毫无破绽，但是在真机上是绘制不出来的！！！ 12还是老老实实转化成网络图片再下载吧！！！相关问题：https://developers.weixin.qq.com/community/develop/doc/00048c046f0028e62247f403651800?highLine=drawimage%2520base64 模拟器坑爹二连 12明明在模拟器上特殊字体是有效的，为什么到了真机上就又变成了默认字体了？？？想要用字体？那就让设计切个图片给你吧 分享参数问题：新用户扫描后处理scene值生成二维码时会带上scene值，当其他人扫描后可以从scene值中解析出有用的参数123456789101112131415decodeURLParams(str) &#123; const result = &#123;&#125; const params = str.split('&amp;'); for (let param of params) &#123; const keyValue = param.split('='); result[keyValue[0]] = keyValue[1]; &#125; return result;&#125;,onLoad() &#123; let bookId = ''; if (options.bookId) bookId = options.bookId; else if (options.scene) bookId = this.decodeURLParams(decodeURIComponent(options.scene)).bookId || ''; this.setData(&#123; bookId: bookId &#125;);&#125;]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(四)：Page能力增强]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%A2%9E%E5%BC%BAPage%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[有一些常用的东西，如 http 请求、弹窗、错误处理等等，如果在每个页面都引用一遍，会增加不必的代码量，我们可以在 app.js 中对 Page 对象进行简单地封装，从而让 Page 的能力更强 Page封装1234567891011121314151617181920212223242526272829import $http from './plugins/http.js';App(&#123; // 展示成功弹窗（toast） showSuccess (title, hideLoading) &#123; if (hideLoading) wx.hideLoading(); wx.showToast(&#123; title, mask: true, duration: 500, icon: 'success' &#125;); &#125;, // 展示失败弹窗（modal） showError (title, content, hideLoading) &#123; if (hideLoading) wx.hideLoading(); wx.showModal(&#123; title, content, showCancel: false &#125;); &#125;, // 增强Page能力，小程序不支持prototype的形式拓展能力 enhancePage() &#123; const oPage = Page; Page = config =&gt; oPage(Object.assign(config, &#123; $http, $showSuccess: this.showSuccess, $showError: this.showError, $showLoading: (title) =&gt; wx.showLoading(&#123; mask: true, title: title &#125;), $hideLoading: () =&gt; wx.hideLoading(), &#125;)); &#125;, onLaunch() &#123; this.enhancePage(); &#125;, 在页面中的应用123456789Page(&#123; onLoad() &#123; this.$http('/api').then(() =&gt; ...) this.$showSuccess('请求成功') this.$showError('请求失败', '请稍后重试') this.$showLoading('数据加载中') this.$hideLoading() &#125;&#125;)]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(三)：Http封装]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fhttp%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[配合 cookie 的模拟，可以实现和浏览器一样的请求体验。 使用方式1234import $http from '../plugins/http.js'$http.get('/api', &#123;key: value&#125;).then(res =&gt; ...)$http.post('/api', &#123;key: value&#125;).then(res =&gt; ...) 原理解读 - http.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import config from '../config';import cookieUtil from './cookie';const getResponse = function (url, data = &#123;&#125;, opt = &#123;&#125;) &#123; opt.url = (/^http/i).test(url) ? url : `$&#123;config.api || ''&#125;$&#123;url&#125;`; opt.data = data; // 手动设置cookie opt.header = Object.assign(opt.header || &#123;&#125;, &#123; Cookie: cookieUtil.getAllString(), &#125;); const reqPromise = new Promise((resolve, reject) =&gt; &#123; const requestTask = wx.request(Object.assign(opt, &#123; // eslint-disable-line success(res) &#123; // 手动模拟set-cookie const setCookieStr = res.header['Set-Cookie'] || res.header['set-cookie']; setCookieStr &amp;&amp; cookieUtil.parseSetCookie(setCookieStr); // 处理返回结果 if (res.statusCode === 200) &#123; resolve(res.data); &#125; else &#123; reject(new Error('网络错误，请稍后再试')); &#125; &#125;, fail() &#123; reject(new Error('网络错误，请稍后再试')); &#125;, &#125;)); // 10秒超时 setTimeout(() =&gt; &#123; requestTask.abort(); reject(new Error('网络超时，请稍后再试')); &#125;, 10000); &#125;); return reqPromise;&#125;;const get = function (url, data = &#123;&#125;, opt = &#123;&#125;) &#123; return getResponse(url, data, opt).then((result) =&gt; &#123; if (result.code === 0) &#123; return result.data; &#125; throw new Error(result.msg || result.message); &#125;);&#125;;const post = function (url, data = &#123;&#125;, opt = &#123;&#125;) &#123; opt.method = 'POST'; opt.header = opt.header || &#123;&#125;; opt.header['Content-Type'] = opt.header['Content-Type'] || opt.header['content-type'] || 'application/json'; return get(url, data, opt);&#125;;export default &#123; get, post, getResponse,&#125;;]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(二)：Cookie模拟]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FCookie%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[众所可能周知，微信小程序是不支持 cookie 的，这就非常影响前后端的沟通，所以不得不自己实现一套 cookie 机制了。 使用方式12345678910111213141516import cookie from '../plugins/cookie.js';cookie.getAllString() // 获取cookie字符串cookie.get('key') // 获取某个cookie值cookie.set('key', 'value') // 设置一个新的cookie值cookie.delete('key') //删除某个cookie值cookie.clear() // 清空cookie// 在http请求头部的使用：设置请求中的cookie值opt.header = Object.assign(opt.header || &#123;&#125;, &#123; Cookie: cookieUtil.getAllString(),&#125;);// 在http请求回调的使用：设置回调中的cookie值const setCookieStr = res.header['Set-Cookie'] || res.header['set-cookie'];setCookieStr &amp;&amp; cookie.parseSetCookie(setCookieStr); 原理解读 - cookie.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * 利用 storage 模拟 cookie 操作 * 请求等情况下数据要求较高，所以需要同步操作 * cookie 存储格式：&#123; key: &#123; value: 'value', expires: 1526452752000 &#125; &#125; */const storageKey = 'reqCookie';const Fn = &#123; // 获取 cookie 字符串 getAllString() &#123; const cookie = this._getAll(); const deleteArr = []; const result = []; Object.keys(cookie).forEach(key =&gt; &#123; if (typeof cookie[key] !== 'object' || this._checkExpires(cookie[key]) || !cookie[key].value) &#123; deleteArr.push(key); &#125; else &#123; result.push(`$&#123;key&#125;=$&#123;cookie[key].value&#125;`); &#125; &#125;); this.batchDelete(deleteArr); return result.join('; '); &#125;, // 获取 cookie 中一个字段 get(key) &#123; if (!key) return; const cookie = this._getAll(); if (this._checkExpires(cookie[key]) || typeof cookie[key] !== 'object') &#123; this.delete(key); &#125; return cookie[key] &amp;&amp; cookie[key].value; &#125;, // 设置 cookie 中一个字段 set(key, value) &#123; if (!key) return false; try &#123; const cookie = this._getAll(); cookie[key] = typeof value === 'object' ? value : &#123; value &#125;; wx.setStorageSync(storageKey, JSON.stringify(cookie)); return true; &#125; catch (e) &#123; console.error(e); // eslint-disable-line return false; &#125; &#125;, // 设置 cookie 多个字段 batchSet(obj) &#123; if (!obj || typeof obj !== 'object') return false; try &#123; const cookie = this._getAll(); Object.keys(obj).forEach(key =&gt; &#123; obj[key] = typeof obj[key] === 'object' ? obj[key] : &#123; value: obj[key] &#125;; &#125;); Object.assign(cookie, obj); wx.setStorageSync(storageKey, JSON.stringify(cookie)); return true; &#125; catch (e) &#123; console.error(e); // eslint-disable-line return false; &#125; &#125;, // 删除 cookie 中一个字段 delete(key) &#123; if (!key) return false; try &#123; const cookie = this._getAll(); cookie[key] &amp;&amp; (delete cookie[key]); // eslint-disable-line wx.setStorageSync(storageKey, JSON.stringify(cookie)); return true; &#125; catch (e) &#123; console.error(e); // eslint-disable-line return false; &#125; &#125;, // 删除 cookie 多个字段 batchDelete(keyArr) &#123; if (!keyArr || !keyArr.length) return false; try &#123; const cookie = this._getAll(); keyArr.forEach(key =&gt; &#123; cookie[key] &amp;&amp; (delete cookie[key]); // eslint-disable-line &#125;); wx.setStorageSync(storageKey, JSON.stringify(cookie)); return true; &#125; catch (e) &#123; console.error(e); // eslint-disable-line return false; &#125; &#125;, // 清除 cookie clear() &#123; try &#123; wx.setStorageSync(storageKey, '&#123;&#125;'); return true; &#125; catch (e) &#123; console.error(e); // eslint-disable-line return false; &#125; &#125;, // 解析 set-cookie parseSetCookie(str) &#123; if (!str) return; const expiresReg = /expires=([^;]+);/gi; const setCookieStr = str.replace(expiresReg, (match, time) =&gt; `expires=$&#123;new Date(time).getTime()&#125;;`).replace(/\s+/gi, ''); const cookieObj = &#123;&#125;; setCookieStr.split(',').forEach(cookieStr =&gt; &#123; let key; cookieStr.split(';').forEach((part, index) =&gt; &#123; try &#123; const cArr = part.split('='); if (index === 0) &#123; key = cArr[0]; cookieObj[key] = &#123; value: cArr[1] &#125;; &#125; else if (cArr[0] === 'expires') &#123; cookieObj[key].expires = cArr[1]; &#125; &#125; catch (e) &#123; console.error(e); // eslint-disable-line &#125; &#125;); &#125;); this.batchSet(cookieObj); &#125;, // 检查 cookie 是否过期 _checkExpires(valueObj) &#123; return valueObj &amp;&amp; valueObj.expires &amp;&amp; Date.now() &gt; valueObj.expires; &#125;, // 获取 cookie 对象 _getAll() &#123; let cookie = &#123;&#125;; try &#123; const storage = wx.getStorageSync(storageKey); cookie = storage ? JSON.parse(storage) : &#123;&#125;; &#125; catch (e) &#123; console.error(e); // eslint-disable-line &#125; return cookie; &#125;,&#125;;export default Fn;]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序打夯之旅(一)：登录流程]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[基础术语123451. code: 调用wx.login后返回的临时登录凭证，可请求微信服务器换取openId和session_key2. openId：用户唯一标识，同一用户在不同的应用中不一致3. session_key：对用户数据进行加密签名的密钥4. appId：小程序唯一标识，申请小程序成功后获得分配5. unionId：用户在开放平台的唯一标识符，同一用户在同一账号下的所有应用中一致 UnionID 机制说明 如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。 UnionID获取途径UnionID 获取途径：绑定了开发者帐号的小程序，可以通过下面的途径获取 UnionID。 调用接口 wx.getUserInfo，从解密数据中获取 UnionID。注意本接口需要用户授权，请开发者妥善处理用户拒绝授权后的情况。 如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号。开发者可以直接通过 wx.login + code2Session 获取到该用户 UnionID，无须用户再次授权。 如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用。开发者也可以直接通过wx.login + code2Session 获取到该用户 UnionID，无须用户再次授权。 用户在小程序（暂不支持小游戏）中支付完成后，开发者可以直接通过 getPaidUnionId 接口获取该用户的 UnionID，无需用户授权。注意：本接口仅在用户支付完成后的5分钟内有效，请开发者妥善处理。 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号，并且该用户已经关注了该公众号，可在云函数中通过 cloud.getWXContext 获取 UnionID。 小程序端调用云函数时，如果开发者帐号下存在同主体的公众号或移动应用，并且该用户已经授权登录过该公众号或移动应用，也可在云函数中通过 cloud.getWXContext 获取 UnionID。 小程序登录流程示意图1231. 通过wx.login() 获取code2. 将code发送给后端，后端请求微信服务器code2Session接口换取openId和sessionKey3. 将openId与唯一登录态绑定并把登录态返回给用户 需要授权的信息部分接口需要经过用户授权同意才能调用，如用户信息、地理位置、地址等等，需要注意的是，如果用户已经拒绝了授权，就不会再出现授权弹窗，此时应该引导用户前往设置界面打开授权，开发者可以调用 wx.openSetting 打开设置界面，引导用户开启授权。 提前发起授权 除了 userInfo，其他的授权信息都可以使用 wx.authorize 提前发起授权，而 userInfo 只能通过 button 触发。123456789101112// 点击后将出发弹窗，点击允许或拒绝将调用回调&lt;button open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt;getUserInfo(e) &#123; // 用户拒绝授权 if (e.detail.errMsg == 'getUserInfo:fail auth deny')&#123; this.showError('您还没有授权微信登录'); &#125; else &#123; // 获取用户信息成功 this.weixinLoginNew(); &#125;&#125; e.detail 数据结构说明(跳过吧) encryptedData: 加密后的用户敏感信息，如openId和unionId iv：加密算法的初始向量，后端通过iv、encryptedData及解密算法进行解密获得openId signature：数据签名，signature = sha1( rawData + session_key )，开发者将 signature、rawData 发送到开发者服务器进行校验。服务器利用用户对应的 session_key 使用相同的算法计算出签名 signature2 ，比对 signature 与 signature2 即可校验数据的完整性。 userInfo：用户非敏感信息，包含头像、昵称、性别等 需要授权的信息列表 scope 对应接口 描述 scope.userInfo wx.getUserInfo 用户信息 scope.userLocation wx.getLocation, wx.chooseLocation 地理位置 scope.address wx.chooseAddress 通讯地址 scope.invoiceTitle wx.chooseInvoiceTitle 发票抬头 scope.invoice wx.chooseInvoice 获取发票 scope.werun wx.getWeRunData 微信运动步数 scope.record wx.startRecord 录音功能 scope.writePhotosAlbum wx.saveImageToPhotosAlbum, wx.saveVideoToPhotosAlbum 保存到相册 scope.camera &lt;camera /&gt;组件 摄像头 获取手机号12345678&lt;button open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"&gt;&lt;/button&gt;Page(&#123; getPhoneNumber(e) &#123; // 揭秘后JSON结构：&#123;phoneNumber(有区号), purePhoneNumber, countryCode &#125; console.log(e.detail.encryptedData) &#125;&#125;) 案例（封装了一个微信登录组件）1. 查看用户设置信息验证是否授权过 12345678910ready() &#123; wx.getSetting(&#123; success: (res) =&gt; &#123; if (res.authSetting['scope.userInfo']) &#123; // 已经授权，可以直接调用 wx.getUserInfo 获取头像昵称 this.setData(&#123; isAuthorization : true&#125;); &#125; &#125; &#125;);&#125; 2. 页面结构如果已经授权过，则可以直接调用 wx.getUserInfo 无需按钮授权，slot 中可以放置任何元素，用以描述登录按钮。 12345&lt;view class="login-wrap" catchtap="weixinLogin"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;button wx:if="&#123;&#123; !isAuthorization &#125;&#125;" open-type="getUserInfo" bindgetuserinfo="getUserInfo" class="wx-btn" size="min"&gt; &lt;/button&gt;&lt;/view&gt; 12345// 数据data: &#123; isAuthorization: false, // 是否已经验证过 canIUse: wx.canIUse('button.open-type.getUserInfo'),&#125;, 12345678910111213141516171819202122/* 样式 */&lt;style lang="scss"&gt;.login-wrap &#123; position: relative;&#125;.wx-btn &#123; width: 100%; height: 100%; position: absolute; left: 0rpx; top: 0rpx; z-index: 100; border-radius:0rpx; background:none; margin:0rpx; padding:0rpx;&#125;.wx-btn:after &#123; border: none;&#125;&lt;/style&gt; 3.处理点击行为如果用户已经授权，则会触发 weixinLogin 事件。12345weixinLogin (e) &#123; if (!this.data.isAuthorization) return; // 通过 wx.login() 完成微信登录 // 通过 wx.getUserInfo() 获取用户信息&#125;, 如果用户未授权过，则会触发 getUserInfo 事件。1234567891011121314// 微信登录按钮触发getUserInfogetUserInfo(e) &#123; if (!this.data.canIUse)&#123; this.showError('请升级微信到最新版本'); return; &#125; if (e.detail.errMsg == 'getUserInfo:fail auth deny')&#123; this.showError('您还没有授权微信登录'); &#125; else&#123; wx.showLoading(&#123; title: 'loading', mask: true &#125;); // 通过 wx.login() 完成微信登录 // 通过 wx.getUserInfo() 获取用户信息 &#125;&#125;]]></content>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从单页应用(SPA)到服务器渲染(SSR)]]></title>
    <url>%2F2019%2F03%2F19%2F%E4%BB%8ESPA%E5%88%B0SSR%2F</url>
    <content type="text"><![CDATA[成也萧何，败也萧何 你为什么要选择SPA？难道就因为交互体验比传统多页更友好嘛？是的，你说的没错。对于用户来讲，响应时间、交互体验更加友善，对于开发者来说，前后端分离的开发模式大大降低了开发成本，这已经完全可以构成放弃SSR的理由了。 如果一切顺利，本文就没有出现的必要了。你猜的没错，我要说但是了！但是，SPA有一个致命的缺陷，就是对搜索引擎不友好，不利于爬虫爬取数据。有人要问了，不利于爬虫不是好事嘛？难道你还想让别人爬你的数据嘛？你咋不上天呢？搜索引擎不爬虫鬼知道你的网站是什么，你靠什么做SEO？靠砸钱嘛？好像也可以.. 用户就是爸爸，如果你拥有大量的用户，哪怕你像拼多多一样还亏着十几个亿，也照样可以申请上市！得用户者得天下！如果你不愿意花大价钱去做SEO，那么还是老老实实地想想怎么优化你的SPA吧。 那么什么对搜索引擎和爬虫友好呢？答案就是静态页面，而非浏览器渲染，这就需要服务器直接渲染，也就是所谓的SSR（Server Side Render） 壮士，干了这一杯SSR SSR，服务器渲染，简单来说就是将每个要展示的页面运行完成后，将整个相应流传送给浏览器，所有的运算都在服务器端完成，浏览器只需要无脑解析HTMl就行。传统的SSR包含哪些？ASP？EJS？JSP？请不要再说了，我想我会永远记得被模板语言支配的恐惧。当用模板语言作为前端开发语言时，至少我是没办法静下心来去美化页面优化交互体验的，所有的精力都花在了业务逻辑上，对于页面的布局毫不关心，如果一定要用一个标准去衡量，那就是，能看就行。 那么到底该如何着手将项目改造成SSR呢？我可不想继续写恐怖的模板语言。Vue2.0中有一章是关于SSR的，可以在无须大幅修改原先代码的情况下做到SSR，又不失单页应用良好的体验。听上去是不是很酷，我们来看看怎么实现吧。 SSR架构 一个普通的单页应用通常通过webpack把源代码打包后插入到html中，当页面请求时，返回html再加载打包后的js文件，也就是下图的Application Code、Webpack build和browser三个部分。 SSR架构图简介：将 Source（源码）通过 webpack 打包出两个 bundle，其中 Server Bundle 是给服务端用的，服务端通过渲染器 bundleRenderer 将 bundle 生成 html 给浏览器用；另一个 Client Bundle 是给浏览器用的，别忘了服务端只是生成前期首屏页面所需的 html ，后期的交互和数据处理还是需要能支持浏览器脚本的 Client Bundle 来完成。 server entry &amp; client entry Server entry 和 Client entry对应的是webpack.config中的entry，即打包入口文件，也就是分别代表服务器端所运行代码的入口和浏览器端所运行代码的入口文件。 12server entry: 根据路由状态，返回渲染完成后相应的组件client entry: 将应用直接挂在到DOM上 Webpack build 既然有了不同的entry，打包自然也就需要两套配置。client端的配置文件本来就有，也并不需要修改。唯一需要增加的，就是server端的配置文件。而server端的配置文件，也可以照抄客户端的配置，改改entry和output就可以了。但是一定要注意，把target属性设置为node。收工完成，得到了server bundle和client bundle。 bundle renderer 到这里需要用到vue为支持ssr所依赖的库：vue-server-renderer。通过vue-server-renderer提供的api很容易地根据url生成对应的目录树，然后将它返回给客户端。因为用的是webpack，所以只能用createBundleRenderer而不能用createRenderer来创建randerer。 老师，我要看DEMO DEMO Time：https://juejin.im/post/5a9ca40b6fb9a028b77a4aac]]></content>
      <tags>
        <tag>SPA</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Resultful风格接口]]></title>
    <url>%2F2019%2F03%2F19%2FResultful%E9%A3%8E%E6%A0%BC%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[你脑壳疼嘛？ 还在为剪不断理还乱的模板语言头疼？还在为前后端傻傻分不清而烦恼？前端分离了解一下，MVVM框架了解一下，如果你的产品是面向用户的，是希望被用户喜欢的，相信我，你不适合SSR（服务器端渲染）。随着网络应用程序复杂度的极速增长，前后端分离的设计方式也变得越来越流行。 你真的懂前端么？ 如果你的前端仅仅停留在网页，对不起，请回炉重造。前端包含各种型号各种系统的手机、平板、网页等其他设计。那么问题来了，不同的系统，不同的实现语言，后端要怎么做才能更好地去对接不同的调用方式？这就是API结构产生的背景，其中Restful API是目前比较成熟的一套互联网应用程序的API设计理论。 麻子是Restful风格 既然叫Restful风格，那么它肯定是一种风格，而不是一个标准，它只提供了一种设计原则和约束条件。主要适用于客户端和服务器端交互的软件。是基于http协议实现的。目的是为了提高系统的可伸缩性，降低应用之间的耦合度，方便框架分布式处理程序。基于这个风格的软件可以更加简单、更有层次、更易于实现缓存的机制。 Restful风格的特点说了那么多废话，是时候来点干货了，相信大部分人只想知道Restful到底要怎么去设计，关于它是什么，它怎么来了，我只想说，关我*事？ 每种url代表了一种资源 客户端和服务器之间，传递这个资源的某种表现层 客户端通过四个http动词，对服务器资源进行操作。实现表现层状态的转化 什么意思？这都不明白？就是每种url代表了一种资源啊。什么是资源？用户信息就是一种资源！书籍信息就是资源！消息就是一种资源！Restful风格指明对一种资源的增删改查操作的请求路径应该是一致的，不同的操作应该以请求方式区分，如新增为POST，删除为DELETE，修改为PUT，查询为GET。 1234POST /user // 创建一个新用户PUT /user // 修改一个用户的信息DELETE /user // 删除一个用户GET /user // 获取一个用户的详细信息 补充：我想大多数人跟我一样在一开始设计API的时候，都喜欢加上一些动词，如下：12345// 下面的接口不符合Restful设计风格！！！！！虽然它们并没有错POST /createUserPOST /updateUserDELETE /deleteUserGET /getUserInfo]]></content>
      <tags>
        <tag>Resultful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript Object 常用方法大全]]></title>
    <url>%2F2019%2F03%2F15%2FJavascript%20Object%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[Object.assign: 将所有可枚举属性的值从一个或多个对象复制到目标对象，并返回目标对象1234567const obj1 = &#123; a: 1, b: 3&#125;const obj2 = &#123; a: 5, c: 6&#125;const obj3 = Object.assign(obj1, obj2)console.log(obj1) // &#123; a: 5, b: 3, c: 6&#125;console.log(obj2) // &#123; a: 5, c: 6&#125;console.log(obj3) // &#123; a: 5, b: 3, c: 6&#125; 1234567const obj1 = &#123; a: 1, b: 3&#125;const obj2 = &#123; a: 5, c: 6&#125;const obj3 = Object.assign(&#123;&#125;, obj1, obj2)console.log(obj1) // &#123; a: 1, b: 3&#125;console.log(obj2) // &#123; a: 5, c: 6&#125;console.log(obj3) // &#123; a: 5, b: 3, c: 6&#125; Object.defineProperty: 定义或修改一个对象中的属性Object.defineProperties: 定义或修改一个对象中的多个属性Object.getOwnPropertyDescriptor: 获取一个对象中的一个属性描述Object.getOwnPropertyDescriptors: 获取一个对象中的所有属性描述123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 数据属性 * [[Configurable]]: 能否通过delete删除此属性，能否修改属性的特征 * [[Enumerable]]: 该属性是否可枚举，即是否可通过for-in或Object.keys()返回属性 * [[Writable]]: 能否修改属性的值 * [[Value]]: 该属性的值，默认为undefined * * 访问器属性 * [[Configurable]]、[[Enumerable]] 和数据属性一致 * [[Get]]: 提供一个 getter 方法，访问对象属性时会调用该方法 * [[Set]]: 提供一个 setter 方法，读取对象属性时会调用该方法 */// definePropertyconst obj = new Object()Object.defineProperty(obj, 'name', &#123; configurable: false, writable: false, enumerable: true, value: '一个不能被修改的名字'&#125;)console.log(obj.name) // '一个不能被修改的名字'// definePropertiesconst obj2 = new Object()Object.defineProperties(obj2, &#123; name: &#123; writable: true, value: '张三' &#125;, Name: &#123; get: function() &#123; return `$&#123;this.name&#125;先生` &#125;, set: function(value) &#123; this.name = value || '未知' &#125; &#125;&#125;)console.log(obj2.name) // 张三console.log(obj2.Name) // 张三先生obj2.Name = ''console.log(obj2.name) // 未知// getOwnPropertyDescriptorObject.getOwnPropertyDescriptor(obj2, 'name') // ...Object.getOwnPropertyDescriptor(obj2) // ... Object.entries: 返回一个对象自身可枚举属性的键值对，顺序与for-in循环时的顺序一致12const obj = &#123; foo: 'bar', baz: 42 &#125;Object.entries(obj) // [["foo", "bar"],["baz", 42]] Object.freeze: 冻结一个对象(只有一层)，不能修改任何信息，包括新增属性、删除属性、修改属性值Object.isFrozen: 判断一个对象是否已经被冻结123456789101112131415161718192021const obj = &#123; a: 1, b: &#123; c: 2 &#125;&#125;console.log(obj.a) // 1console.log(obj.b.c) // 2obj.a = 3obj.b.c = 4console.log(obj.a) // 3console.log(obj.b.c) // 4Object.isFrozen(obj) // falseObject.freeze(obj)Object.isFrozen(obj) // trueobj.a = 5obj.b.c = 6console.log(obj.a) // 3console.log(obj.b.c) // 6 Object.keys: 获取一个对象中所有的key值(不包括不可枚举属性和Symbol属性)Object.values: 获取一个对象中所有的value值（不包括不可枚举属性和Symbol属性）123456789const obj = &#123;&#125;Object.defineProperty(obj, 'a', &#123;Enumerable: false, value: 1&#125;)obj[Symbol()] = 2obj['b'] = 3console.log(Object.keys(obj)) // ['b']console.log(Object.values(obj)) // ['3']console.log(Object.getOwnPropertyNames(obj)) // ['a', 'b']console.log(Object.getOwnPropertySymbols(obj)) // [Symbol()] Object.getOwnPropertyNames: 获取一个对象所有属性的key值(包括不可枚举属性，不包括Symbol属性)12345const obj = &#123; foo: 'bar', baz: 43&#125;Object.getOwnPropertyNames(obj) // ['foo', 'baz'] Object.getOwnPropertySymbols: 获取一个对象所有Symbol属性1234const obj = &#123;&#125;obj[Symbol('a')] = 'localSymbol'obj[Symbol.for('b')] = 'globalSymbol'Object.getOwnPropertySymbols(obj) // [Symbol(a), Symbol(b)] 拓展：Symbol是为了保证对象属性的一致性1234567const sy = Symbol('a')const obj = &#123;&#125;obj[Symbol('a')] = 3 // &#123;Symbol(a): 3&#125;obj[sy] = 4 // &#123;Symbol(a): 3, Symbol(a): 4&#125;console.log(obj[Symbol('a')]) // undefinedconsole.log(obj[sy]) // 4 Object.preventExtensions: 使一个对象不再具有拓展性（不能添加新属性）Object.isExtensible: 判断一个对象是否具有拓展性123456const obj = &#123;v1: 1&#125; // &#123;v1:1&#125;obj.v2 = 2 // &#123;v1:1, v2:2&#125;Object.preventExtensions(obj)obj.v3 = 3 // &#123;v1:1, v2:2&#125;obj.v2 = 3 // &#123;v1:1, v2:3&#125;Object.isExtensible(obj) // false hasOwnProperty: 判断一个对象是否包含某个属性(不包括原型链上的属性)123const obj = &#123; a: 2 &#125;obj.hasOwnProperty('a') // trueobj.hasOwnProperty('b') //false isPrototypeOf: 判断一个对象是否在某个对象的原型链上12345678function fn() &#123;&#125;_fn1 = new fn() // fn &#123;&#125;_fn2 = fn() // undefinedconsole.log(fn.isPrototypeOf(_fn1)) // falseconsole.log(fn.prototype.isPrototypeOf(_fn1)) // trueconsole.log(fn.prototype.isPrototypeOf(_fn2)) // falseconsole.log(Object.prototype.isPrototypeOf(_fn1)) // trueconsole.log(Object.prototype.isPrototypeOf(_fn2)) // false]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript数组方法大全]]></title>
    <url>%2F2019%2F03%2F14%2FJavascript%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[搜罗了目前 Javascript 数组所有的方法，迷失道路的小伙伴可以直接查看页面右边的目录 数组创建1234const arr1 = [1, 2, 3]; // [1, 2, 3]const arr2 = Array(); // []const arr3 = Array(2); // [undefined, undefined]const arr4 = Array(1,2,3); // [1, 2, 3] Array.from: 将一个对象转化成数组1234567891011/* * 第一个参数：被转化的数组 * 第二个参数：对每个元素进行处理，将处理后的结果放入返回的数组（类似于map） * 第三个参数：用来绑定this */// 当参数为一个Object类型时，需要有length属性，用来指定数组长度，默认为0Array.from(&#123; 2: '2', a: 'a', 0: '0', length: 4&#125;) // ['0', undefined, 2: undefined]Array.from(&#123; 2: '2', a: 'a', 0: '0', length: 2&#125;) // ['0', undefined]Array.from(&#123; 2: '2', a: 'a', 0: '0', length: 2&#125;, v =&gt; v || '') // ['0', '']Array.from('hello') // ['h', 'e', 'l', 'l', 'o'] Array.isArray: 判断传递的值是否是一个 Array 类型12345Array.isArray([1,2,3]) // trueArray.isArray(&#123;a: 'a'&#125;) // falseArray.isArray('hello') // falseArray.isArray(Array(3)) // trueArray.isArray(null) // false Array.of: 把所有的参数放到一个数组中返回12const arr1 = Array.of(1, 2, 3); // [1, 2, 3]const arr1 = Array.of(); // [] Array.apply: 创建空数组123456/* * 第一个参数：用来绑定this * 第二个参数：数组参数(参考Array.from的第一个参数) */Array.apply(null, &#123;1:'1', length: 2&#125;) // [undefined, '1'] Array.apply(null, {length: 2} 与 Array(2) 的区别: Array(2) 只有 length，没有索引和元素，所以不能用 map 12345678const arr1 = Array.apply(null, &#123;length: 2&#125;) // [undefined, undefined]const arr2 = Array(2) // [empty x 2]1 in arr1 // true1 in arr2 // falsearr1.map(v =&gt; 1) // [1, 1]arr2.map(v =&gt; 1) // [empty x 2] concat: 合并多个数组并返回一个新数组(原有数组不变)12345const arr1 = [1, 2]const arr2 = ['a', 'b']const arr3 = ['hello']const arr4 = arr1.concat(arr2, arr3) // [1, 2, 'a', 'b', 'hello'] copyWithin: 从数组的指定位置拷贝元素到另一个指定位置12345678/* * 第一个参数：复制的目标位置 * 第二个参数：复制的开始位置(闭区间) * 第三个参数：复制的结束位置(开区间) */const arr = [1,2,3,4,5,6]arr.copyWithin(4, 1, 3) // [1,2,3,4,2,3] entries: 返回一个数组的迭代对象(Iterator)123456const arr = [1,2,3]const it = arr.entries()console.log(it.next()) // &#123;value: [0,1], done: false&#125;console.log(it.next()) // &#123;value: [1,2], done: false&#125;console.log(it.next()) // &#123;value: [2,3], done: false&#125;console.log(it.next()) // &#123;value: undefined, done: true&#125; every: 对数组中所有的元素进行检查，返回布尔值some: 和every类似，every是需要所有元素都满足条件，而some只要有满足的就会返回true1234const arr = [1,2,3]arr.every(v =&gt; &#123; console.log(v); return v &lt; 10&#125;) // 1 2 3 truearr.every(v =&gt; &#123; console.log(v); return v &lt; 2&#125;) // 1 2 falsearr.some(v =&gt; &#123; console.log(v); return v &lt; 2&#125;) // 1 true fill: 用一个固定值替换数组中的元素123456789/* * 第一个参数：填充的值 * 第二个参数：填充的开始位置(闭区间) * 第三个参数：填充的结束位置(开区间) */const arr = [1,2,3,4,5,6]arr.fill(0, 1, 3) // [1,0,0,4,5,6]Array(2).fill(0) // [0,0] filter: 创建一个新数组，返回原数组中满足条件的所有元素12345678910111213141516const arr1 = [ &#123; age: 10, name: '10'&#125;, &#123; age: 23, name: '23'&#125;, &#123; age: 16, name: '16'&#125;, &#123; age: 11, name: '11'&#125;, &#123; age: 37, name: '37'&#125;]arr1.filter(v =&gt; v.age &lt; 18)// 输出/* [ * &#123; age: 10, name: '10'&#125;, * &#123; age: 16, name: '16'&#125;, * &#123; age: 11, name: '11'&#125; * ] */ find: 返回数组中第一个满足条件的元素findIndex: 返回数组中第一个满足条件的元素的索引值12345678const arr1 = [ &#123; age: 10, name: '10'&#125;, &#123; age: 23, name: '23'&#125;, &#123; age: 16, name: '16'&#125;, &#123; age: 11, name: '11'&#125;, &#123; age: 37, name: '37'&#125;]arr1.find(v =&gt; v.age &gt; 18) // &#123; age: 23, name: '23'&#125; flat: 创建一个新数组，扁平化原嵌套数组，参数为扁平的层数，该方法会移除空项12345const arr1 = [1, , [2, [3, , [4]]]]arr.flat() // [1,2,[3, , [4]]]arr.flat(2) // [1,2,3,[4]]arr.flat(3) // [1,2,3,4]arr.toString() // '1,,2,3,,4' flatMap: 和 map 相近，但是会将返回结果压平一层123const arr1 = [1,2,3]arr1.map(v =&gt; [v * 2]) // [[2], [4], [6]]arr1.flatMap(v =&gt; [v * 2]) // [2, 4, 6] forEach: 遍历数组中的每一个元素12const arr1 = [1,2,3]arr1.forEach(v =&gt; console.log(v)) // 1,2,3 includes: 判断一个数组中是否包含一个元素12345678910const obj = &#123;id: 2, value: '2'&#125;const arr = [ obj, 'hello', &#123;id: 1, value: '1'&#125;]arr.includes(&#123;id: 1, value: '1'&#125;) // falsearr.includes(obj) // truearr.includes('hello') // true indexOf: 找到满足条件的元素的索引值，第一个参数是开始寻找的位置lastIndexOf: 寻找顺序与indexOf相反 findIndex 的能力比 indexOf 更强，findIndex 相当于一个 for 循环，可以进行逻辑处理和判断，而 indexOf 能力较弱 123const arr1 = ['a', 'b', 'c','b']arr1.indexOf('b') // 1arr1.lastIndexOf('b') // 3 join: 将元素连接成一个字符串，并用分隔符分割（第一个参数），元素会执行 toString12const arr = [1, 'b', &#123;c: 2&#125;, [3,4]]arr.join(' &amp; ') // "1 &amp; b &amp; [object Object] &amp; 3,4" keys: 和 entries 类似，但是返回的为 索引，而不再是 key/valuevalues: 和 entries 类似，但是返回的为 值，而不再是 key/value123456const arr = [1,2,3]const it = arr.keys()console.log(it.next()) // &#123;value: 0, done: false&#125;console.log(it.next()) // &#123;value: 1, done: false&#125;console.log(it.next()) // &#123;value: 2, done: false&#125;console.log(it.next()) // &#123;value: undefined, done: true&#125; map: 返回一个新数组，数组中的元素为原数组经过处理后的值12const arr1 = [&#123;id:1&#125;, &#123;id:2&#125;, &#123;id: 3&#125;]arr1.map(v =&gt; v.id) // [1, 2, 3] pop: 删除原数组的最后一个元素push: 在原数组的末尾添加一个元素shift: 删除原数组的第一个元素unshift: 在原数组开头添加一个元素12345const arr = [1,2,3]arr.pop() // 3; arr: [1,2]arr.shift() // 1; arr: [2]arr.push(3) // 2; arr: [2,3]arr.unshift(4) // 2; arr: [4,2,3] reduce: 接受一个累加器，数组中的每个值开始缩减，最终计算为一个值reduceRight: 功能和reduce一样，只是是从末尾向前做累加12345const arr = [1,2,3]function getSum(total, currentValue, currentIndex, arr) &#123; return total + currentValue;&#125;arr.reduce(getSum, 10) // 16; arr: [1,2,3] reverse: 颠倒原数组中元素的顺序12const arr = [1,2,3]arr.reverse() // [3,2,1] slice: 提取数组中的子串到新数组splice: 删除原数组中的子串123const arr = [1,2,3,4,5]arr.slice(2,4) // [3,4]; arr: [1,2,3,4,5]arr.splice(1,2) // [2,3]; arr: [1,4,5] sort12345const asc = (a,b) =&gt; a - bconst des = (a,b) =&gt; b - aconst arr = [3,1,4,2,7]arr.sort(asc) // [1, 2, 3, 4, 7]arr.sort(des) // [7, 4, 3, 2, 1]]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序中实现状态管理]]></title>
    <url>%2F2019%2F03%2F04%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[出发点：之前起点小程序尝试mpvue的一个重要原因就是mpvue支持状态管理，虽然现在wepy也支持了redux，但是其性能不是非常理想，且看到issue里面还是提了很多的bug，所以还是想着用原生来撸一个简单够用的。 Pub/Sub模式（发布/订阅模式）状态管理中非常重要的点就是发布/订阅模式，发布/订阅模式的原理非常简单，一边发布，一边订阅。订阅者在事件中心注册具名事件和回调函数，发布者通知事件中心执行所有同名的回调函数。 1订阅者 ---- 注册事件 ----&gt; 事件中心 &lt;---- 通知 ---- 订阅者 事件中心（pubsub.js）既然需要提供事件注册（订阅）的功能，那么必然需要一个地方来存放所有的事件，同一个事件名可以有多个回调，那么显然数据结构如下： 1234&#123; &apos;fn_name&apos;: [fn1, fn2, fn3...], ...&#125; 所以事件中心的雏型如下： 12345678910111213141516export default class PubSub &#123; constructor() &#123; // events里存放的是所有的具名事件 this.events = &#123;&#125;; &#125; // 提供订阅功能 subscribe(event, callback) &#123; ... &#125; // 提供发布功能 publish(event, data) &#123; ... &#125;&#125; 订阅功能：在具名事件的回调数组中推入了一个新的回调，接受一个事件名和回调函数。123456789subscribe(event, callback) &#123; let self = this; if(!self.events.hasOwnProperty(event)) &#123; self.events[event] = []; &#125; // 没有做去重 return self.events[event].push(callback);&#125; 发布功能：调用对应事件名的所有回调函数，参数为事件名和回调参数。 12345678910publish(event, data = &#123;&#125;) &#123; let self = this; if(!self.events.hasOwnProperty(event)) &#123; return []; &#125; return self.events[event].map(callback =&gt; callback(data));&#125; Store对象（store.js）该对象主要用于存储共享数据，当数据被更新时触发 stageChange 事件。123456789101112131415161718192021222324252627282930313233343536373839404142434445import PubSub from '../lib/pubsub.js';export default class Store &#123; constructor(params) &#123; let self = this; self.actions = &#123;&#125;; // 存储异步方法 self.mutations = &#123;&#125;; // 存储同步方法 self.state = &#123;&#125;; // 共享数据 self.status = 'resting'; // 防止手动更新 self.events = new PubSub(); // 参数可以传入初始的actions和mutations if(params.hasOwnProperty('actions')) &#123; self.actions = params.actions; &#125; if(params.hasOwnProperty('mutations')) &#123; self.mutations = params.mutations; &#125; // Proxy：es6的方法，起到拦截的作用 self.state = new Proxy((params.state || &#123;&#125;), &#123; set: function(state, key, value) &#123; state[key] = value; console.log(`stateChange: $&#123;key&#125;: $&#123;value&#125;`); self.events.publish('stateChange', self.state); // 防止手动更新 if(self.status !== 'mutation') &#123; console.warn(`You should use a mutation to set $&#123;key&#125;`); &#125; self.status = 'resting'; return true; &#125; &#125;); &#125; dispatch(actionKey, payload) &#123; ... &#125; commit(mutaionKey, payload) &#123; ... &#125;&#125; dispatch：调用 actions，可以执行一些异步的操作，然后调用commit12345678910111213141516171819dispatch(actionKey, payload) &#123; let self = this; if(typeof self.actions[actionKey] !== 'function') &#123; console.error(`Action "$&#123;actionKey&#125; doesn't exist.`); return false; &#125; console.groupCollapsed(`ACTION: $&#123;actionKey&#125;`); self.status = 'action'; self.actions[actionKey](self, payload); console.groupEnd(); return true;&#125; commit：调用mutations12345678910111213141516commit(mutationKey, payload) &#123; let self = this; if(typeof self.mutations[mutationKey] !== 'function') &#123; console.log(`Mutation "$&#123;mutationKey&#125;" doesn't exist`); return false; &#125; self.status = 'mutation'; let newState = self.mutations[mutationKey](self.state, payload); self.state = Object.assign(self.state, newState); return true;&#125; 案例（状态管理的应用）需求说明：在首页将一本书加入书架，书架列表自动更新。 store/state.js123export default &#123; bookList: [],&#125;; store/mutation.js123456export default &#123; addBook(state, payload) &#123; state.bookList.push(payload); return state; &#125;&#125;; store/action.js12345export default &#123; addBook(context, payload) &#123; context.commit('addBook', payload); &#125;,&#125;; store/index.js12345678910import actions from './actions.js';import mutations from './mutations.js';import state from './state.js';import Store from './store.js';export default new Store(&#123; actions, mutations, state&#125;); 订阅（书架页）1234567import store from '../store/index.js';store.events.subscribe('stateChange', (params) =&gt; &#123; this.setData(&#123; bookList: params.bookList &#125;);&#125;); 发布（首页）12import store from '../store/index.js';store.dispatch('addBook',&#123;bookid: 203&#125;);]]></content>
      <tags>
        <tag>微信小程序</tag>
        <tag>Pub/Sub</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pre Commit]]></title>
    <url>%2F2019%2F03%2F01%2FPre-Commit%2F</url>
    <content type="text"><![CDATA[最终效果：每次提交代码时，自动完成以下两个功能 执行代码增量检查，有代码风格错误抛出异常。 检查提交的文件列表，如果同时存在 dist 目录和非 dist 目录，抛出异常。 前期准备在阅读本文之前，请确保熟悉或了解 eslint、 eslint-staged 和 husky. 如果不了解，请点击传送门：Javascript代码检查那点事 代码增量检查 eslint 的具体配置不再赘述，在上述的传送门中有详细配置。 安装相关依赖12npm install --save-dev huskynpm install --save-dev lint-staged 在 package.json 中增加如下配置123456789101112131415161718&quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;node scripts/utils/pre-commit.js&quot; &#125;&#125;,&quot;lint-staged&quot;: &#123; &quot;linters&quot;: &#123; &quot;*.js&quot;: [ &quot;eslint&quot;, &quot;git add&quot; ], &quot;*.vue&quot;: [ &quot;eslint&quot;, &quot;git add&quot; ] &#125;, &quot;ignore&quot;: [&quot;dist/**&quot;]&#125;, 配置说明：当执行 git commit 时，会执行 husky.hooks.pre-commit, 也就是 node scripts/utils/pre-commit.js，该命令为执行一段脚本，脚本如下。 提交文件检查 检查提交内容的核心思路为：获取本次提交的改动文件列表信息 -&gt; 检查文件路径 -&gt; 判断是否同时存在 dist 和非 dist目录，如果同时存在，则抛出异常停止 commit 操作，如果不存在，则执行 eslint 代码检查。详细代码如下（可直接拷贝到 scripts/utils/pre-commit.js 中） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120const chalk = require('chalk')const symbols = require('log-symbols')const spawn = require('child_process').spawnrequire('lint-staged')// 检查改动的文件目录getDiffFiles().then(files =&gt; &#123; const filePaths = files.map(file =&gt; file.filename.split('/')[0]) let isDistFolder = false let isOtherFiles = false filePaths.forEach(path =&gt; &#123; if (path === 'dist') isDistFolder = true else isOtherFiles = true &#125;) if (isDistFolder &amp;&amp; isOtherFiles) &#123; throw new Error() &#125; runCmd('lint-staged')&#125;).catch(() =&gt; &#123; /* eslint-disable */ console.error(`\n\n$&#123;symbols.error&#125; $&#123;chalk.redBright('Ops！Dist folder and other files cannot be submitted at the same time.')&#125;`) console.log(` (use "git reset" to cancel the "add" operation)\n`) /* eslint-enable */ process.exit(1)&#125;)// 获取本次改动的文件列表function getDiffFiles() &#123; return getHeadCommitId().then(head =&gt; &#123; if (head) &#123; const command = 'git -c core.quotepath=false diff-index --cached --name-status -M --diff-filter=ACM ' + head return runCmd(command).then((&#123; err, stdout, stderr &#125;) =&gt; &#123; return err || stderr ? err || new Error(stderr) : stdoutToResultsObject(stdout) &#125;) &#125; &#125;)&#125;// 获取最近一次提交的commit_idfunction getHeadCommitId() &#123; return runCmd('git rev-parse --verify HEAD').then((&#123; err, stdout, stderr &#125;) =&gt; &#123; if (err &amp;&amp; err.message.indexOf('fatal: Needed a single revision') !== -1) &#123; return getFirstCommitId() &#125; else &#123; return err || stderr ? err || new Error('STDERR: ' + stderr) : stdout.replace('\n', '') &#125; &#125;)&#125;// 获取第一次提交的commit_idfunction getFirstCommitId() &#123; return runCmd('git hash-object -t tree /dev/null').then((&#123; err, stdout, stderr &#125;) =&gt; &#123; return err || stderr ? err || new Error('STDERR: ' + stderr) : stdout.replace('\n', '') &#125;)&#125;// 执行命令，监听控制台信息function runCmd(command) &#123; return new Promise((resolve) =&gt; &#123; // 解析命令获取参数 const bits = command.split(' ') const args = bits.slice(1) // 执行命令 const cmd = spawn(bits[0], args, &#123; cwd: process.cwd() &#125;) let stdout = '' let stderr = '' cmd.stdout.on('data', data =&gt; &#123; stdout += data.toString() &#125;) cmd.stderr.on('data', data =&gt; &#123; stderr += data.toString() &#125;) cmd.on('close', code =&gt; &#123; const err = code !== 0 ? new Error(stderr) : null resolve(&#123; err, stdout, stderr &#125;) &#125;) &#125;)&#125;// 把stdout输出信息转化成Object对象function stdoutToResultsObject(stdout) &#123; const results = [] const lines = stdout.split('\n') let iLines = lines.length while (iLines--) &#123; const line = lines[iLines] if (line !== '') &#123; const parts = line.split('\t') const result = &#123; filename: parts[2] || parts[1], status: codeToStatus(parts[0]), &#125; results.push(result) &#125; &#125; return results&#125;// git 枚举映射function codeToStatus(code) &#123; const map = &#123; A: 'Added', C: 'Copied', D: 'Deleted', M: 'Modified', R: 'Renamed', T: 'Type-Change', U: 'Unmerged', X: 'Unknown', B: 'Broken', &#125; return map[code.charAt(0)]&#125; 当执行 git commit 操作时，首先会执行上述脚本，当满足要求时，再执行 eslint 代码检查，当代码检查通过后，才会提交代码到远程仓库！]]></content>
      <tags>
        <tag>Github</tag>
        <tag>hooks</tag>
        <tag>Github钩子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript代码检查那点事]]></title>
    <url>%2F2019%2F02%2F28%2FJavascript%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5%E9%82%A3%E7%82%B9%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[一时不做规范一时爽，一直不做规范一直爽。阿呸，代码规范这事，可小可大，如果一个项目长期没有规范检查，那么随着参与人数和代码量的增加，就会存在很多的潜在地雷，随时可能爆炸！本文将介绍如何安装和使用 EditorConfig、 eslint 、 eslint staged，从而实现 Javascript 代码的增量检查。 一统代码风格 - EditorConfig代码规范，从本地开始在这里必须介绍一款神器：EditorConfig，它可以帮助开发人员在不同编辑器和IDE中定义和维护一致的代码风格。该神器的精华全在一个叫做 .editorconfig 的文件中，我们来看一下一个典型的.editorconfig文件。 1234567891011// 当打开一个文件时，EditorConfig插件会在打开文件的目录// 和其每一级父目录查找.editorconfig文件，直到有一个配置文件root=trueroot = true[*]charset = utf-8 // 定义编码格式indent_style = space // 定义缩进类型为空格而不是tabindent_size = 4 // 定义缩进为4个空格end_of_line = lf // 定义行尾转行字符类型insert_final_newline = true // 文件保存时自动在末尾添加一行空行trim_trailing_whitespace = true // 自动删除行尾空格 浅显易懂有木有？且.editorconfig 的配置优先级将高于编辑器本身的配置，所以只要在项目根目录下创建该文件，那么就可以保证代码风格的一致性！ 那么问题来了，只要手动创建该文件就运行了嘛？答案当然是不！像 webstorm 已经默认支持了 editorconfig， 但是像 sublime 则需要安装额外的插件。 在 Sublime 中安装 Editorconfig12345// Mac1. 打开package control：subline text -&gt; preferences -&gt; package control2. 打开install pakage：输入pacakge control:intall packages3. 安装插件：输入editor config双击安装插件4. 使用：在项目根目录中添加一个.editorconfig文件，在文件中添加代码规则 那么问题又来了，虽然你本地做了代码风格统一，但你不能保证每一个参与者的编辑器都支持 EditorConfig，难道每加入一个开发者你都要去喊他安装 EditorConfig 嘛？答案当然是可以的，不过最好还是做一层兜底！所以就需要用到 eslint 来做代码检查！ 代码全量检查 - ESLint什么是ESLint ESLint是一个插件化的JS代码检测工具，可以用于检查常见的JS代码错误，也可以进行代码风格检查，通过ESLint配置，可以辅助编码规范的执行，有效控制项目代码的质量。 为什么要用ESLint JS是非常灵活的弱类型语言，如果不进行约束，可能在某个特定的时候就爆出了xxx is undefined的错误而导致程序崩溃，所以需要辅助工具来帮助我们检查代码。 ESLint的优势与劣势 较早的代码检测插件如JSHint和JSCS，无法检测React JSX的语法，虽然衍生出了JSXHint等，但是并不是以插件的形式出现，而是重新包装了一个工具。但是JSHint的速度要比ESLint更快。 ESLint的特点 默认规则包含了JSHint和JSLint的规则。 规则可配置性高：可设置警告、错误两个error等级。 包含代码风格检测的规则（可以丢掉JSCS了） 支持插件拓展、自定义规则。 开干！完成代码自动检查！安装 eslint 和 pre-commit 12npm install --save-dev eslintnpm install --save-dev pre-commit 在 package.json 中配置 eslint 检查和 pre-commit 123456&quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint --ext js,vue [需要检查的目录] --cache&quot;&#125;,&quot;pre-commit&quot;: [ &quot;lint&quot;], 创建 eslint 检查规则：在项目根目录下创建 .eslintrc.js 文件，下面为一份配置 Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 项目说明：该项目是基于Vue2.0的项目// 在'plugin:vue/essential'和'airbnb-base'风格的基础上关闭了一些规则检查module.exports = &#123; root: true, "extends": ['plugin:vue/essential', 'airbnb-base'], "globals": &#123; // 定义了可以使用的全局对象 "Vue": true, "VueRouter": true &#125;, "plugins": ["vue"], "env": &#123; "browser": true, "node": true, "es6": true, &#125;, "parserOptions": &#123; "parser": "babel-eslint", "sourceType": "module" &#125;, "rules": &#123; "func-names": "off", "global-require": "off", "linebreak-style": "off", "indent": ["error", 2, &#123; "SwitchCase": 1 &#125;], "import/extensions": "off", "import/first": "off", "import/no-extraneous-dependencies": "off", "import/no-unresolved": "off", "import/prefer-default-export": "off", "no-mixed-operators": "off", "no-new": "off", "no-param-reassign": "off", "no-plusplus": "off", "no-return-assign": "off", "vars-on-top": "off", "import/no-dynamic-require": "off", "no-restricted-syntax": "off", "no-underscore-dangle": "off", "semi": [2, "never"], "no-use-before-define": "off", "consistent-return": "off", "no-else-return": "off", "no-shadow": "off", "no-useless-escape": "off", "no-restricted-globals": "off", "operator-linebreak": "off", "no-multi-assign": "off", "prefer-destructuring": "off", "lines-between-class-members": "off", "prefer-template": "off", "camelcase": "off", "prefer-rest-params": "off", "no-unused-expressions": "off", "no-confusing-arrow": "off", "no-prototype-builtins": "off", "arrow-body-style": "off", "prefer-promise-reject-errors": "off", "arrow-parens": "off", "object-curly-newline": "off", "max-len": "off", "no-nested-ternary": "off", "newline-per-chained-call": "off", "no-new-func": "off", "prefer-spread": "off", "quotes": [2, "single", &#123; "allowTemplateLiterals": true &#125;], /* for vue */ "valid-v-bind": "off", "v-bind-style": "off" &#125;&#125; 查看效果：如果是一个老项目，你可能会看到上千个报红！1npm run lint 恭喜你，到此为止你每一次提交代码时都会自动完成一次全量检查！没错，是全量！对于老项目或者是比较大的项目，这是不合理的，所以需要优化为增量检查。 增量检查，GO！- Lint Staged 检测所有文件很慢且有的结果是无关紧要的，你更改关心的是本次改动的内容。这就是lint-staged的用处。 安装 lint-staged 和 husky 1npm install --save-dev lint-staged husky 把之前全量检查在 package.json 中添加的内容全部删除，在 package.json 中添加如下内容 123456789101112131415// 只检查本次提交（add）的// husky 会在commit时自动执行 precommit 命令"scripts": &#123; "precommit": "lint-staged"&#125;,"lint-staged": &#123; "*.js": [ "eslint", "git add" ], "*.vue": [ "eslint", "git add" ]&#125;, 完美，到此就完成了代码的增量检查！]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>增量检查</tag>
        <tag>eslint</tag>
        <tag>eslint-staged</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oh-my-zsh]]></title>
    <url>%2F2019%2F02%2F28%2FOh-my-zsh%2F</url>
    <content type="text"><![CDATA[zsh 是一个虚拟终端，原先不同的终端有不同的命令，现在通过这个虚拟终端就可以执行所有的命令，如可以执行git命令、subline命令等。本文将介绍 zsh 在 mac 中的安装和使用。 安装1234567891011# 安装1. curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh# 创建配置文件2. cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc# 设置zsh为默认终端3. chsh -s /bin/zsh# 安装完成后会自带一些主题，也可以去下面的地址下载主题放到 ~/.oh-my-zsh/themes 下4. https://github.com/robbyrussell/oh-my-zsh/wiki/themes 修改主题12341. 打开配置文件：open ~/.zshrc2. 修改配置文件：ZSH_THEME=你想要的主题，默认为robbyrussell3. 让配置文件生效：source ~/.zshrc4. 主题推荐：ys，ys是安装时自带的，无需额外下载 自动补全插件 incr1234567891. 下载：http://mimosa-pudica.net/zsh-incremental.html2. 进入plugins文件夹：cd ~/.oh-my-zsh/plugins3. 创建一个新的文件夹并进入：mkdir incr; cd incr4. 创建一个新的文件：touch incr-0.2.zsh5. 把下载下来的文件拷贝过来：cp /Users/jasper/Downloads/incr-0.2.zsh incr-0.2.zsh6. 赋予该文件最高权限：chmod 777 ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh7. 在./zshrc中加入这样一句话：source ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh8. 让配置文件生效：source ~/.zshrc9. 配置完成，现在已经有自动补全了 路径跳转插件autojump 其实用到的频率并不高，如果命令行卡的话不建议安装 只要你访问过某路径如/a/b/c/d，那么下次你输入j d就可以快速进入该路径12341. 找个地方准备下载如Downloads：git clone git://github.com/joelthelion/autojump.git2. 进入autojump文件夹：cd autojump3. 运行安装文件：./install.py4. 根据提示，将下面的命令复制到~/.zshrc中 1[[ -s /Users/jasper/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /Users/jasper/.autojump/etc/profile.d/autojump.sh 125. 更新配置： source ~/.zshrc6. 安装完成 代码高亮插件zsh-syntax-highlightingzsh-syntax-highlighting 可以高亮一些常用命令如cd、open等121. 下载插件： git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting2. 在.zshrc的plugins中添加zsh-syntax-highlighting，plugins=&#123;... zsh-syntax-highlighting&#125; 不用安装的插件这些插件只需要在 .zshrc 的 plugins 里面添加即可，如 plugins={git web-search}，添加后需要重启终端 1231. web-search: 可以快速进行搜索，如google test或者baidu test，就会打开浏览器并进行搜索2. last-working-dir：打开终端的默认路径为上一次离开时的路径（推荐）3. wd: 可以给目录添加索引，进入/a/b/c/d然后执行wd add test，之后无论在哪里执行wd test都会进入到/a/b/c/d]]></content>
      <tags>
        <tag>oh-my-zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github小白指南]]></title>
    <url>%2F2019%2F02%2F28%2FGithub%E5%B0%8F%E7%99%BD%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[咳咳，有如此完美的可视化界面不用，偏偏要用命令行，何必呢！命令行这东西，按需获取，当你遇到需要完成的操作无从下手时，可以过来看看，没必要全部记下来。 老司机专属链接：Git 常用命令列表 零基础：仓库初长成Scene1: 我是项目的创建者，在git上已经创建了一个新的仓库，我要怎么推送本地代码到远端仓库？123451. git init // 在项目的根目录执行，初始化本地仓库2. git remote add [rmt_name] [git_url] // 构建远程仓库连接3. git push [rmt_name] master // 将本地代码推送到远端的master分支 Scene2: 我是项目的参与者，git上已经有了代码仓库，我要怎么参与开发？1git clone [git_url] // 复制远程仓库到本地 入门：贡献自己一份力Scene1: 我对本地仓库进行了修改，我要怎么提交到远端仓库？1234567891. git status // 查看哪些文件被修改了，发现所有的文件修改都是你所希望的2. git add . // 将所有的文件修改都添加到暂存区3. git commit -m "本次提交的信息" // 将暂存区的内容提交到本地仓库4. git pull [origin] [branch_name] // 拉取并合并远端的仓库，发现没有任何冲突，太开心了5. git push [origin] [branch_name] // 将本地仓库提交到远端仓库 Scene2: 我想撤销对某些文件的修改(还没有add)12345671. git status // 查看哪些文件被修改了，发现有些文件不应该被修改2. git checkout [file_name] // 撤销对原有文件的修改，如果有多个文件，重复执行此操作// 2. 如果想撤销所有修改，git checkout .3. git clean -df // 恢复新增的或删除的文件 Scene3: 我想撤回add操作（已经add但是还没commit）1git reset // 把add的文件全部从暂存区取出来，如果只想取出单个文件，后面可以跟文件名 Scene4: 我想撤回commit操作（已经commit但是还没有进行push）1231. git log // 查看所有的提交日志，复制上一次commit的commit_id2. git reset --soft [commit_id] // 撤销此次commit并保留所有的修改 Scene5: 我进行了commit操作，但是我发现我的标签写错了，怎么办？1231. git commit --amend // 执行后编辑信息保存即可(你可能需要一些简单的vim知识)2. git commit --amend --reset-author // 修改上一次提交的作者信息 Scene6: 我想回滚到之前的某一个版本123456781. git log // 查看提交日志，复制你想要回滚到的那一次提交的commit_id// 注意：此次回滚为强制回滚，这之后的所有修改都不会被保存// 如果你后悔了，只需要到远端仓库中复制当前head的commit_id再执行一遍此操作即可2. git reset --hard [commit_id]// 此操作红色报警，不到万不得已千万不要用！！！3. git push -f [rmt_name] [branch_name] // 强制覆盖远端仓库，即进行远端仓库的回滚，此操作不可逆 Scene7: 最不想看到的结果，pull或者merge的时候发生冲突了12345671. 根据合并结果对所有的冲突进行手动处理2. git add .3. git commit -m "合并信息" // 重新提交一遍4. git push [rmt_name] [branch_name] Scene8: 想查看某个文件具体的修改内容？1git diff [file_name] // 对比该文件修改前后的区别，如果无文件名将对比所有文件的修改 Scene9：我想查看所有的提交记录123451. git log // 查看所有的提交记录2. git log [branch_name] // 查看某分支的提交记录3. glog // 等价于 git log --oneline，简化日志，一次提交占一行，有利于全局观察 进阶：花里胡哨的一份力Scene1: 我要新建一个分支123451. git branch [new_branch_name] // 创建一个新的分支2. git checkout [new_branch_name] // 如果需要切换到新分支请执行此命令// 上面两个步骤可以合并为 git checkout -b [branch_name] Scene2: 我要查看现有的所有分支1git branch // 查看分支 Scene3: 分支开发完了，我要合并到主分支master上123451. git checkout master // 切换到master2. git merge [branch_name] // 合并分支到master，如果有冲突，你懂的3. git merge --patch [branch_name] [file_name] // 只合并单个文件到master上，比较少用 Scene4: 分支开发完了，也就没有存在的必要了1231. git branch -d [branch_name] // 删除本地分支, -d会判断是否合并，-D会强制删除2. git push rmt --delete [branch_name] // 删除远程仓库的分支 大师：优化提交记录 - rebase 超高能警报！！虽然rebase可以简化提交记录，如果你用的是 Source Tree 等可视化工具，那么点一下就可以了，如果是用的命令行，请在熟练使用过 rebase 命令的高手陪伴下使用该命令！！！否则！！！后果你承担不起！！！ 普通的提交最大的问题，就是有太多的 commit，当参与人数较多时，会出现大量的如merge这种无用的commit日志，而且在查看提交记录图时，会有很多从分支上合并到主分支的线条，看起来不美观。 123456789// 下面的流程会把本地的commit一一粘贴到master上，而不是merge// 2、3步骤可以合并为 git pull -rebase orgin master1. git commit -m ''2. git fetch orgin/master3. git rebase orgin/master4. git push orgin master 无卵用：不常用但是一定会用到的命令Scene1: 管理现有的仓库链接123451. git remote // 查看现有的远程仓库链接名2. git remote -v // 相比于上一条多了url信息，更加详细3. git remote rm [rmt_name] // 删除一个现有链接 Scene2: 配置本地git的信息1231. git config --global user.name [user_name] // 配置用户名2. git config --global user.email [user_email] // 配置邮箱 打标签（tag）1231. git tag v1.0 commit_id // 给某一此commit添加tag2. git push origin master --tags // 把本地的标签push到远程仓库 Git 常用命令列表1234567891011121314151617181920212223242526272829303132333435361. git init // 初始化本地仓库2. git remote add [rmt_name] [git_url] // 构建远程仓库连接3. git pull [rmt_name] [branch_name] // 拉取远程分支并自动合并4. git push [rmt_name] [branch_name] // 将本地代码推送到远端的master分支5. git fetch [rmt_name] [branch_name] // 拉取远程分支，但不自动6. git clone [git_url] // 拷贝远程仓库到本地7. git status // 查看哪些文件被修改了，发现所有的文件修改都是你所希望的8. git add . // 将所有的文件修改都添加到暂存区9. git commit -m "本次提交的信息" // 将暂存区的内容提交到本地仓库10. git checkout [file_name] // 撤销对原有文件的修改，如果有多个文件，重复执行此操作11. git checkout . // 撤销本次所有的修改12. git clean -df // 恢复新增的或删除的文件13. git reset // 把add的文件全部从暂存区取出来，如果只想取出单个文件，后面可以跟文件名14. git reset --soft [commit_id] // 撤销此次commit并保留所有的修改15. git reset --hard [commit_id] // 撤销此次commit并删除所有的修改16. git log // 查看所有的提交日志17. git log --oneline // 查看所有的提交日志（简化版）18. git log [branch_name] // 查看某分支的提交记录19. git commit --amend // 修改上一次提交的信息（未push）20. git commit --amend --reset-author // 修改上一次提交的作者信息（未push）21. git push -f [rmt_name] [branch_name] // 强制覆盖远端仓库，即进行远端仓库的回滚，此操作不可逆22. git diff [file_name] // 对比该文件修改前后的区别，如果无文件名将对比所有文件的修改23. git branch [new_branch_name] // 创建一个新的分支24. git checkout [new_branch_name] // 切换到新分支25. git branch // 查看分支26. git merge [branch_name] // 合并分支27. git merge --patch [branch_name] [file_name] // 只合并单个文件28. git branch -d [branch_name] // 删除本地分支, -d会判断是否合并，-D会强制删除29. git push rmt --delete [branch_name] // 删除远程仓库的分支30. git remote // 查看现有的远程仓库链接名31. git remote -v // 相比于上一条多了url信息，更加详细32. git remote rm [rmt_name] // 删除一个现有链接33. git config --global user.name [user_name] // 配置用户名34. git config --global user.email [user_email] // 配置邮箱35. git tag v1.0 commit_id // 给某一此commit添加tag36. git push origin master --tags // 把本地的标签push到远程仓库]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JQuery原理]]></title>
    <url>%2F2019%2F02%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JQuery%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文将手把手逐渐实现一个简化版的 JQuery。 先来自己动手简化选择器base 是一个对象，拥有两个方法，方法名为 $、$$，功能分别为通过 id 和 class 来获取元素。 123456789101112var base = &#123; $:function(id)&#123; return document.getElementById(id); &#125;, $$:function(className)&#123; return document.getElementsByClassName(className); &#125;&#125;//使用base.$("id"); //返回相应的元素对象base.$$("class"); //返回相应的元素对象集合 进阶，向JQuery靠拢声明一个全局方法 $，用于返回一个 base 对象。 12345678910111213141516var $ = function()&#123; return new Base();&#125;function Base()&#123; this.$ = function(id)&#123; return document.getElementById(id); &#125;; this.$$ = function(className)&#123; return document.getElementsByClassName(className); &#125;;&#125;//使用$().$("id"); //返回相应的元素对象$().$$("class"); //返回相应的元素对象集合 加上css方法增加 css 方法，就可以通过 el.css().css() 链式调用的形式给元素增加样式。 12345678910111213141516171819202122232425262728293031var $ = function()&#123; return new Base();&#125;function Base()&#123; this.elements = [] //创建一个数组，来保存获取的节点和节点数组 this.$ = function(id)&#123; //因为每一次使用$都会新建对象，所以不需要清空，不会异常 this.elements.push(document.getElementById(id)); return this; //一定要返回对象，不然无法进行连缀 &#125;; this.$$ = function(className)&#123; var clss = document.getElementsByClassName(className); for(var i = 0 ;i &lt; clss.length; i++)&#123; this.elements.push(clss[i]); &#125; return this; &#125;; this.css = function(attr,val)&#123; for(var i = 0;i &lt; this.elements.length; i++)&#123; this.elements[i].style[attr] = val; &#125; return this; &#125;&#125;//使用$().$("id").css("color","white").css("background","black"); //返回相应的元素对象$().$$("class").css("color","red").css("border","1px dotted black"); //返回相应的元素对象集合 加上eq方法用于遍历元素，添加一个 current 变量即可12345678910111213141516171819202122232425262728293031323334353637383940var $ = function()&#123; return new Base();&#125;function Base()&#123; this.elements = []; //创建一个数组，来保存获取的节点和节点数组 this.current = -1; //用于遍历 this.$ = function(id)&#123; //因为每一次使用$都会新建对象，所以不需要清空，不会异常 this.elements.push(document.getElementById(id)); return this; //一定要返回对象，不然无法进行连缀 &#125;; this.$$ = function(className)&#123; var clss = document.getElementsByClassName(className); for(var i = 0 ;i &lt; clss.length; i++)&#123; this.elements.push(clss[i]); &#125; return this; &#125;; this.eq = function(index)&#123; this.current = index; return this; &#125; this.css = function(attr,val)&#123; if(this.current != -1)this.elements[this.current].style[attr] = val; else&#123; for(var i = 0;i &lt; this.elements.length; i++)&#123; this.elements[i].style[attr] = val; &#125; &#125; return this; &#125;&#125;//使用$().$("id").css("color","white").css("background","black"); //返回相应的元素对象$().$$("class").eq(1).css("color","red").css("border","1px dotted black"); //返回相应的元素对象集合 通过$(“str”)来获取元素进一步封装 $ 函数，从而使得调用方法对标 JQuery。 $(&#39;#id&#39;).css().css() $(&#39;.class&#39;).eq(2).css().css() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var $ = function(str)&#123; var base = new Base(); if(str[0] == "#")&#123; base.$(str.substr(1,str.length - 1)); &#125; else if(str[0] == '.')&#123; base.$$(str.substr(1,str.length - 1)); &#125; else&#123; //TagName &#125; return base;&#125;function Base()&#123; this.elements = []; //创建一个数组，来保存获取的节点和节点数组 this.current = -1; //用于遍历 this.$ = function(id)&#123; //因为每一次使用$都会新建对象，所以不需要清空，不会异常 this.elements.push(document.getElementById(id)); return this; //一定要返回对象，不然无法进行连缀 &#125;; this.$$ = function(className)&#123; var clss = document.getElementsByClassName(className); for(var i = 0 ;i &lt; clss.length; i++)&#123; this.elements.push(clss[i]); &#125; return this; &#125;; this.eq = function(index)&#123; this.current = index; return this; &#125; this.css = function(attr,val)&#123; if(this.current != -1)this.elements[this.current].style[attr] = val; else&#123; for(var i = 0;i &lt; this.elements.length; i++)&#123; this.elements[i].style[attr] = val; &#125; &#125; return this; &#125;&#125;//使用$("#id").css("color","white").css("background","black"); //返回相应的元素对象$(".class").eq(1).css("color","red").css("border","1px dotted black"); //返回相应的元素对象集合]]></content>
      <tags>
        <tag>Javascript</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript内存结构分析]]></title>
    <url>%2F2019%2F02%2F20%2FJavascript%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[虽然很少触及，但是网页也是有内存上限的，当 html、javascript等数据大小超过上限时，浏览器可能会闪退或停止响应。本文将介绍网页的内存结构、Javascript 垃圾回收机制以及函数闭包。 网页内存结构：堆 + 栈 + 池 池：存放常量 栈：存放定义的变量和函数 堆：存放对象（new） 12345// str存放在栈中，"hello world"存放在常量池中，str只是一个饮用var str = "hello world";// 在堆中开辟了一个对象，str2是对该对象的引用，而该对象是对"hello world"常量的引用，也就是二级引用var str2 = new String("hello world"); 案例分析123456789str1 = &quot;hello&quot;;str2 = String(&quot;hello&quot;);str3 = new String(&quot;hello&quot;);str1 == str2：true //比较的是前者和后者的值str1 == str2：truestr2 == str3：truestr1 === str2：true //比较前者和后者的内存地址str1 === str3：falsestr2 === str3：false Javascript垃圾回收机制str3 为一个对象引用，当 str3 赋值为其他值的时候，原本的对象会被自动清除。 清除原理：垃圾回收器定期巡视堆中所有对象，当发现对象没人引用时，就清除。 也就是说，对象清除不是实时的，而是需要等待一定时间的。 函数闭包函数在调用之前只存在栈中，只要一调用就会在堆中创建一个闭包空间，执行完成后就被回收。 闭包空间中在使用变量时，优先使用闭包空间中的变量，不管是在之前还是之后调用。如果在闭包空间中没有找到，则直接找全局变量，而不是父函数变量。 12345678910var num1 = 10;var num2 = 20;function func1()&#123; num1 = 5; num2 = 10; var num2; //此处定义了num2，所以上面对num2的修改是对这个变量的修改&#125;fun1();alert(num1); //5alert(num2); //20 1234567891011121314var num1 = 10;var num2 = 20;function func1()&#123; num1 = 5; num2 = 10; func2(); var num2;&#125;function func2()&#123; num2 = 30; //此处修改了num2，闭包中没找到，直接找全局变量，而不是找fun1中的&#125;fun1();alert(num1); //5alert(num2); //30]]></content>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5分钟搞定个人博客]]></title>
    <url>%2F2019%2F02%2F19%2F5%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[民间有传言，没有手撸过个人网站的程序员不是一个好的前端开发工程师，可是！强撸灰飞湮灭！为了自己的身体健康，还是少撸为妙！不要998，也不要98，完全免费，hexo你直接带回家。通过hexo，可以快速构建个人博客，并搭建到 github 上供他人访问，三秒真男人，我们开始吧！ 1. 新建仓库都说了要给他人访问，如果你连个仓库都没有，是不是说不过去？出门右转上 github 新建一个仓库，仓库名必须为 &lt;user-name&gt;.github.io 格式，其中 &lt;user-name&gt; 是你 github 的昵称。不要问我为什么，问我我也不想回答你。 2. 全局安装hexo如果你连 npm 是啥都不知道，对不起，我们的缘分尽了，你走吧。…别，别，别，开个玩笑，有啥问题可以留言。打开命令行，输入下面的命令，全局安装 hexo。1npm install -g hexo 3. 初始化项目Just one 命令，hexo init，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦！过程一定要快，凉了就不好吃了！1234hexo init// 本地运行hexo s 4. 部署到github虽然只有一份 Hello World，但是我也想让全世界的人看到，成为最闪耀的那个崽，可咋整？不要慌，快速在项目根目录下找到 _congif.yml，找到 deploy 字段并填写完整，下面请开始你上学时最擅长的事情：抄写！123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;你的仓库地址&gt; # https://github.com/TJ-XiaJiaHao/TJ-XiaJiaHao.github.io branch: master 抄写完毕！但是！我们需要额外的一个工具来帮助我们推到仓库上，那就是！那就是！那就是 hexo-deployer-git。搞它！1npm install hexo-deployer-git --save 万事俱备，只欠东南风！执行下面两个命令，就可以把项目自动部署到 github 上啦啦啦啦啦。123hexo cleanhexo deploy 5. 查看效果凡是连环杀手都喜欢在杀人后留在现场，因为他喜欢欣赏自己的杰作！1浏览器访问：https://tj-xiajiahao.github.io/ 即可看到效果。 至此，已经完成了个人博客的搭建，也可以在浏览器中访问，下面将介绍一些常用的野外生存技能。 如何创建新文章阳光明媚，一杯温暖的咖啡，一束倾斜的阳光，惬意地抿一口咖啡，我要开始写博客了！ 1234// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。// &lt;title&gt; 为文章标题// 如 hexo new post 除了帅气，我还有啥！hexo new [layout] &lt;title&gt; 更换主题皮肤风格不喜欢？换之。 更换主题流程：下载主题 -&gt; 配置主题，以 xoxo 为例（不要想歪了！） 12345# 下载到themes文件夹下git clone https://github.com/KevinOfNeu/hexo-theme-xoxo xoxo# 修改 _config.yml 配置theme: xoxo 部署优化每次都要执行 hexo clean 和 hexo deploy，不如写个新的脚本 123// package.json"dev": "hexo s","build": "hexo clean &amp; hexo deploy" 部署命令 1npm run build]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
